2026-01-05_122331_tg_assert_debate.md — Grounded debate on TG_ASSERT absence in crddagt_cpp
Author: AI (ChatGPT)
Date: 2026-01-05 (America/Los_Angeles)
Document status: Active

## Purpose
Create a grounded, open-ended debate document about whether and how to introduce a `TG_ASSERT`-like facility in the lightweight `crddagt_cpp` project, referencing the existing `demo_002` implementation for context while avoiding premature conclusions.

## Context snapshot
- `demo_002` uses a dedicated assertion facility (`TG_ASSERT`, `TG_ASSERT_CFG`, `TG_TRACE`) with rich messaging, configuration, and death-test support.
- `crddagt_cpp` is intentionally minimal, dependency-free (except the C++ standard library), and avoids heavy runtime facilities. It currently lacks a project-wide assertion macro or equivalent.
- The question is not whether assertions are useful, but whether the project should mirror `demo_002`’s approach, adopt a smaller subset, or remain assertion-free and use other error strategies.

## Evidence and anchors (for grounding)
- `demo_002/src/demo_002/common/project_assert.hpp` defines `TG_ASSERT` and supporting macros, and mandates its usage for key invariants.
- `demo_002` uses `TG_ASSERT` heavily across core graph invariants, usage analysis, and specialized algorithms (e.g., Tarjan SCC, equivalence classes, dependency sorting).
- In `demo_002` thought docs, `TG_ASSERT` is assumed to be an explicit part of runtime correctness and testing (death tests), with its behavior considered part of the API contract.

## Problem statement
`crddagt_cpp` currently has no analogous mechanism for consistent assertion handling or assertion messaging. This raises questions about:
- How to communicate invariant violations to developers.
- How to structure test expectations around fail-fast behavior.
- How to keep the project minimal while still supporting correctness diagnostics.

## Design options (non-exhaustive, not mutually exclusive)
### Option A: No custom assertion facility (status quo)
- Rely on standard `assert`, exceptions, or documented preconditions.
- Pros: maximal simplicity, no new code, minimal surface area.
- Cons: inconsistent diagnostics, weak message control, unclear test patterns.

### Option B: Minimal `CRDDAGT_ASSERT` macro
- Introduce a small macro in `crddagt_cpp`, using `std::logic_error` or `std::runtime_error` with a formatted message.
- Keep configuration minimal (on/off, maybe verbose toggle).
- Pros: consistent diagnostics, easy to reason about, still small.
- Cons: still adds custom facility; may need policy on exception type and behavior.

### Option C: Port a subset of `TG_ASSERT`
- Bring in a trimmed version of `demo_002`’s `TG_ASSERT` (without external dependencies).
- Keep message format and configuration behavior close to `demo_002` to preserve parity across projects.
- Pros: reuse proven approach; consistent developer experience across repos.
- Cons: risk of over-allocating complexity in a minimal project; potential drift or tight coupling to `demo_002` conventions.

### Option D: Compile-time assertions and explicit error channels only
- Favor `static_assert` for compile-time invariants, plus explicit error-return types (e.g., `Expected<T, Err>` or `std::optional` with error details).
- Pros: encourages explicit error handling, avoids runtime assert facility.
- Cons: more verbose APIs, introduces new error types or patterns, may be misaligned with existing usage in `demo_002`.

## Constraints and consistency considerations
- **C++17 only**: no C++20 or later features.
- **No third-party dependencies**: any facility must be standard-library-only.
- **Minimal project ethos**: avoid large policy frameworks or heavy macros unless justified.
- **Testing approach**: if assertions are used, should there be a standard way to test them? (death tests vs. exception-based tests).
- **API stability**: what behavior should be part of the API contract vs. debug-only checks?

## Potential impacts
- **Developer experience**: consistent, actionable diagnostics speed debugging; lack of such increases friction.
- **User expectations**: if `crddagt_cpp` is a core component, do consumers expect fail-fast behavior or recoverable errors?
- **Portability**: careful about behavior differences between debug/release builds.

## Open questions (explicitly unresolved)
1. **Policy scope**: Should invariant enforcement be centralized (single macro), or ad-hoc by component?
2. **Behavior contract**: Should assertions throw exceptions, abort, or be compiled out in release builds?
3. **Message format**: Are we standardizing on message templates, or allow any string? Should it include function/class names?
4. **Testing**: If `CRDDAGT_ASSERT` exists, should tests include death-test coverage, or should assertions be exception-based for testability?
5. **Parity with `demo_002`**: Is alignment with `TG_ASSERT` behavior a priority, or is independence preferred?
6. **Minimalism threshold**: What is the acceptable size/complexity for an assertion facility in this project?
7. **Error types**: If we throw, do we use `std::logic_error`, `std::runtime_error`, or a custom exception type?
8. **Configurability**: Do we need scope-based config (like `TG_ASSERT_CFG`) or only compile-time toggles?
9. **Performance**: Do we need compile-time elimination of assertions in release, or always-on checks?

## Pending decisions / available choices
- **Decision 1**: Adopt a custom assert facility vs. none.
  - Choices: A (none), B (minimal macro), C (subset of TG_ASSERT), D (explicit error channels).
- **Decision 2**: Define default runtime behavior.
  - Choices: throw exception, `std::abort`, `assert`-style termination, or compile-out.
- **Decision 3**: Define test strategy.
  - Choices: exception-based testing, death tests, or avoid direct assertion testing.
- **Decision 4**: Define message and context requirements.
  - Choices: free-form strings only, or standardized fields (file, line, function, class, custom message).

## Notes for future contributors
- Keep the discussion grounded in actual usage patterns from `demo_002`, but do not assume the same constraints apply.
- Avoid binding decisions to `demo_002` unless it is explicitly a cross-project requirement.
- This document should evolve as new evidence is collected (e.g., concrete failure cases, test design needs).
